#!/usr/bin/env python

import os
import numpy as np
import argparse
import nibabel as nib
import json
from time import time

from ants_tbss.functions import get_wildcard, antsLinearRegCmd, antsNonLinearRegCmd, antsApplyTransformCmd, antsBetCmd, round_mask_transform, nifti_to_float_precision

DESCRIPTION = "TBSS (FSL) implementation with ANTs and T1w registration to template."

def getArgumentParser(parser = argparse.ArgumentParser(description = DESCRIPTION)):
	registration = parser.add_mutually_exclusive_group(required=True)
	registration.add_argument("-ar", "--antsregtotemplate", 
		nargs = 2,
		help = "Register B0 to native T1w brain image. -ar {B0 list} {T1w list}",
		metavar = 'str')
	registration.add_argument("-j", "--jsontransformlist", 
		nargs = 1,
		help = "-j {json list}",
		metavar = 'str')
	parser.add_argument("-r", "--runtbss", 
		nargs = '+',
		help="For skeletonization of dwi metrics in template (standard) space, input a text file of the directory locations of the images and the metric name. The first input must be for FA (or the FA skeletonization has to be detected). -r {metric_list} {metric_name} ...")

	# options
	parser.add_argument("-ab","--runantsbet",
		action = 'store_true',
		help="Run ANTs bet on the T1w images. Use this if your T1 inputs are not already brain extracted. Arguably, ANTs does a must better brain extraction than FSL's bet or freesurfer's watershed.")
	parser.add_argument("-nlws","--nonlinearwithinsubject",
		action = 'store_true',
		help="Run an additional non-linear transformation of the linear transformed B0 image to the native space T1w image. This is useful if EPI distortions are present.")
	parser.add_argument("-f","--usefloat",
		action = 'store_true',
		help="Convert ANTs output to float32. This is a hacky solution because of an ANTS/ITK bug that sometimes causes errors when converting to float32 precision.")
	parser.add_argument("-k","--removeinversetransform",
		action = 'store_true',
		help="Delete the inverse transforms from the non-linear transformations. The file size is large, and they are not needed for ants_tbss.")

	# settings
	parser.add_argument("-t","--threshold",
		nargs=1,
		help="Set threshold level. Default: %(default)s)",
		default=['0.2'],
		metavar=('float'))
	parser.add_argument("-nt", "--numthreads", 
		nargs=1,
		default=['12'],
		help="multithreading")
	parser.add_argument("-std", "--templateimage", 
		nargs=1,
		default=['%s/data/standard/MNI152_T1_1mm_brain.nii.gz' % os.environ['FSLDIR']],
		metavar=('img'),
		help="Template (standard) image. Default: %(default)s). -std PATH/TO/TEMPLATE.nii.gz")
	parser.add_argument("--searchrulemask", 
		nargs=1,
		default=['%s/data/standard/LowerCingulum_1mm.nii.gz' % os.environ['FSLDIR']],
		metavar=('img'),
		help="Search rule mask for skeletonization. Default: %(default)s). -std PATH/TO/SEARCH_RULE_MASK.nii.gz")

	return parser

def run(opts):
	# get time stamp
	currentTime=int(time())

	thresh = float(opts.threshold[0])
	num_threads = int(opts.numthreads[0])
	std_brain = opts.templateimage[0]
	current_dir = os.getcwd()
	float_flag = False
	if opts.usefloat:
		float_flag = True

	assert "ANTSPATH" in os.environ, "The environment variable ANTSPATH must be declared."
	ANTSPATH = os.environ['ANTSPATH']
	assert "FSLDIR" in os.environ, "The environment variable FSLDIR must be declared."
	FSLDIR = os.environ['FSLDIR']

	if opts.antsregtotemplate:
		# read list files
		B0_list = np.genfromtxt(opts.antsregtotemplate[0], dtype=str)
		T1_native_list = np.genfromtxt(opts.antsregtotemplate[1], dtype=str)

		# create empty warp list to populate
		warp_list = []
		mask_list = []

		# optional antsBrainExtraction.sh
		if opts.runantsbet:
			Betted_T1 = []
			os.system("mkdir T1w_Brain")
			for T1w in T1_native_list:
				t1_name = os.path.basename(T1w)[:-7]
				print("Running antsBrainExtraction.sh on:\t%s" % t1_name)
				with open("cmd_ants_bet_%d" % currentTime, "a") as cmd_ants_bet:
					cmd_ants_bet.write("%s\n" % antsBetCmd(numthreads = 1, input_image = T1w, output_image_brain = 'T1w_Brain/%s_' % t1_name))
				Betted_T1.append('T1w_Brain/%s_BrainExtractionBrain.nii.gz' % t1_name)
			os.system("cat cmd_ants_bet_%d | parallel -j %d; rm cmd_ants_bet_%d" % (currentTime, num_threads, currentTime))
			T1_native_list = np.array(Betted_T1, dtype=str)

		print("Running registration of B0 images -> T1w images -> template T1 image")
		os.system("mkdir -p reg")
		# check ipout list lenths
		assert len(B0_list) == len(T1_native_list), "The image lists are not of equal length."

		for i, b0 in enumerate(B0_list):
			temp_transformation = {}
			b0_name = os.path.basename(b0)[:-7]
			t1_name = os.path.basename(T1_native_list[i])[:-7]

			mask_name = "reg/%s_mask.nii.gz" % b0_name
			mask_name_t1 = "reg/%s_mask_to_natT1.nii.gz" % b0_name
			mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % b0_name
			t1_mask_name = "reg/%s_mask.nii.gz" % t1_name
			t1_mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % t1_name

			ref = T1_native_list[i]
			temp_transformation['nativeT1'] = T1_native_list[i]

			mov = b0
			log = "reg/lin%s_to_natT1.log" % b0_name
			out = "reg/lin%s_to_natT1.nii.gz" % b0_name

			# binarize the B0 images to create mask (they should already be brain extracted!)
			img = nib.load(mov)
			img_data = img.get_data()
			img_data[img_data!=0] = 1
			nib.save(nib.Nifti1Image(img_data,img.affine), mask_name)

			# linear reg of B0 to T1w native image
			with open("cmd_linB0_to_natT1_%d" % currentTime, "a") as cmd_linB0_to_natT1:
				cmd_linB0_to_natT1.write("%s > %s\n" % (antsLinearRegCmd(int(1), ref, mov, out, use_float = False), log))
			# Option for additional non-linear registration of the lin_B0_to_natT1 to native-T1. It is useful for EPI distorted DWI data.
			if opts.nonlinearwithinsubject:
				mov = "reg/lin%s_to_natT1.nii.gz" % b0_name
				log = "reg/%s_to_natT1.log" % b0_name
				nl_out = "reg/%s_to_natT1.nii.gz" % b0_name
				with open("cmd_B0_to_natT1_%d" % currentTime, "a") as cmd_B0_to_natT1:
					cmd_B0_to_natT1.write("%s > %s\n" % (antsNonLinearRegCmd(int(1), ref, mov, nl_out, use_float = False), log))
				temp_transformation['B0_to_natT1'] = ['%s_0Warp.nii.gz' % (nl_out), '%s_0GenericAffine.mat' % (out)]
			else:
				temp_transformation['B0_to_natT1'] = ['%s/%s_0GenericAffine.mat' % (current_dir, out)]

			# linear reg T1 to std
			ref = std_brain
			mov = T1_native_list[i]
			log = "reg/lin%s_to_stdT1.log" % t1_name
			out = "reg/lin%s_to_stdT1.nii.gz" % t1_name
			with open("cmd_linT1_to_stdT1_%d" % currentTime, "a") as cmd_linT1_to_stdT1:
				cmd_linT1_to_stdT1.write("%s > %s\n" % (antsLinearRegCmd(int(1), ref, mov, out, use_float = False), log))

			# non-linear reg T1 to std
			mov = out
			log = "reg/%s_to_stdT1.log" % t1_name
			out = "reg/%s_to_stdT1.nii.gz" % t1_name
			with open("cmd_T1_to_stdT1_%d" % currentTime, "a") as cmd_T1_to_stdT1:
				cmd_T1_to_stdT1.write("%s > %s\n" % (antsNonLinearRegCmd(int(1), ref, mov, out, use_float = False), log))

			warps = ['%s_0Warp.nii.gz' % (out), 'reg/lin%s_to_stdT1.nii.gz_0GenericAffine.mat' % (t1_name)]
			temp_transformation['T1to_stdT1'] = ['%s/%s_0Warp.nii.gz' % (current_dir, out), '%s/reg/lin%s_to_stdT1.nii.gz_0GenericAffine.mat' % (current_dir, t1_name)]

			mask_list.append(mask_name_std)
			mask_list.append(t1_mask_name_std)

			temp_transformation['mask_name_std'] = mask_name_std
			temp_transformation['t1_mask_name_std'] = t1_mask_name_std

			# Write out the processing settings
			with open('reg/%s_warps.json' % b0_name, 'w') as outfile:
				json.dump(temp_transformation, outfile, indent=3, sort_keys=True)
			warp_list.append('reg/%s_warps.json' % b0_name)

		warp_list = np.array(warp_list, dtype = str)
		os.system("cat cmd_linB0_to_natT1_%d | parallel -j %d; rm cmd_linB0_to_natT1_%d" % (currentTime, num_threads, currentTime))
		if opts.nonlinearwithinsubject:
			os.system("cat cmd_B0_to_natT1_%d | parallel -j %d; rm cmd_B0_to_natT1_%d" % (currentTime, num_threads, currentTime))
		os.system("cat cmd_linT1_to_stdT1_%d | parallel -j %d; rm cmd_linT1_to_stdT1_%d" % (currentTime, num_threads, currentTime))
		os.system("cat cmd_T1_to_stdT1_%d | parallel -j %d; rm cmd_T1_to_stdT1_%d" % (currentTime, num_threads, currentTime))
		if opts.removeinversetransform:
			os.system('rm reg/*0InverseWarp.nii.gz')
		if opts.usefloat:
			print("Converting all NIFTI images in reg/* to use float32 dtype.")
			nifti_images = np.array(get_wildcard('reg/*.nii.gz'))
			if img in nifti_images:
				nifti_to_float_precision(img)

		# read the information for the warps
		for i, b0 in enumerate(B0_list):
			B0_to_natT1 = []
			T1to_stdT1 = []
			std_masks = []
			T1_ref = []
			for json_warp_file in warp_list:
				with open(json_warp_file) as json_file:
					transform_files = json.load(json_file)
					B0_to_natT1.append(transform_files['B0_to_natT1'])
					T1to_stdT1.append(transform_files['T1to_stdT1'])
					std_masks.append(transform_files['mask_name_std'])
					std_masks.append(transform_files['t1_mask_name_std'])
					T1_ref.append(transform_files['nativeT1'])

		# build the masks
		for i, b0 in enumerate(B0_list):
			# set names again ... fix this laziness later
			b0_name = os.path.basename(b0)[:-7]
			t1_name = os.path.basename(T1_native_list[i])[:-7]
			mask_name = "reg/%s_mask.nii.gz" % b0_name
			mask_name_t1 = "reg/%s_mask_to_natT1.nii.gz" % b0_name
			mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % b0_name
			t1_mask_name = "reg/%s_mask.nii.gz" % t1_name
			t1_mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % t1_name

			# move the B0 mask to ref
			ref = T1_ref[i]
			mov = mask_name
			warps = B0_to_natT1[i]
			outname = mask_name_t1
			os.system(antsApplyTransformCmd(reference = ref,
														mov = mov,
														warps = warps,
														outname = outname))
			# round image
			round_mask_transform(mask_name_t1)

			# ref B0 mask to template
			os.system("fslmaths %s -bin %s" % (mov, t1_mask_name))
			ref = std_brain
			mov = mask_name_t1
			warps = T1to_stdT1[i]
			outname = mask_name_std
			os.system(antsApplyTransformCmd(reference = ref,
														mov = mov,
														warps = warps,
														outname = outname))
			# round image
			round_mask_transform(mask_name_std)

			# move T1 mask
			ref = std_brain
			mov = t1_mask_name
			warps = T1to_stdT1[i]
			outname = t1_mask_name_std
			os.system(antsApplyTransformCmd(reference = ref,
														mov = mov,
														warps = warps,
														outname = outname))
			round_mask_transform(t1_mask_name_std)

	if opts.jsontransformlist:
		# Load a list of json files with the transformation infomation (i.e., for metrics in --runtbss).
		warp_list = np.genfromtxt(opts.jsontransformlist[0], dtype=str)

	if opts.runtbss:
		# Check runtbss inputs
		assert len(opts.runtbss) % 2 == 0, "--runtbss must have an even number of inputs. e.g., -r FA_list FA MD_list MD"

		# Check warp list length.
		assert len(warp_list) == len(np.genfromtxt(opts.runtbss[0], dtype=str)), "The length the --runtbss inputs must match the number of warps."

		B0_to_natT1 = []
		T1to_stdT1 = []
		std_masks = []
		T1_ref = []
		# read the json files containing the warps and mask files
		for json_warp_file in warp_list:
			with open(json_warp_file) as json_file:
				transform_files = json.load(json_file)
				B0_to_natT1.append(transform_files['B0_to_natT1'])
				T1to_stdT1.append(transform_files['T1to_stdT1'])
				std_masks.append(transform_files['mask_name_std'])
				std_masks.append(transform_files['t1_mask_name_std'])
				T1_ref.append(transform_files['nativeT1'])

		num_metrics = int(np.divide(len(opts.runtbss),2))
		for m in range(num_metrics):
			METRICS_list = np.genfromtxt(opts.runtbss[int(m*2)], dtype=str)
			METRIC = opts.runtbss[(int(m*2)+1)]
			if METRIC != 'FA':
				assert (os.path.exists('TBSS/mean_FA_skeleton_mask_dst.nii.gz')), "FA skeletonization must be run first."

			os.system("mkdir -p %s_native" % METRIC)
			os.system("mkdir -p %s" % METRIC)

			# transform the metric images to standard space
			for i, metric_img in enumerate(METRICS_list):
				metric_name = os.path.basename(metric_img)[:-7]
				# set output names
				metric_nat = '%s_native/%s_to_natT1.nii.gz' % (METRIC, metric_name)
				metric_std = '%s/%s_to_stdT1.nii.gz' % (METRIC, metric_name)

				# metric to native
				ref = T1_ref[i]
				mov = metric_img
				warps = B0_to_natT1[i]
				os.system(antsApplyTransformCmd(reference = ref, mov = mov, warps = warps, outname = metric_nat))

				# metric to template
				ref = std_brain
				mov = metric_nat
				warps = T1to_stdT1[i]
				os.system(antsApplyTransformCmd(reference = ref, mov = mov, warps = warps, outname = metric_std))


			#### Skeletonization ####
			if METRIC == 'FA':
				tbssdir = 'TBSS'
				os.system("mkdir %s" % tbssdir)
				FA_std = get_wildcard('FA/*FA_to_stdT1.nii.gz')
				# build all_FA_mask
				masks = std_masks
				# check lengths
				assert len(FA_std)*2 == len(masks), "The image lists are not equal to the number of masks."

				#get first mask
				tmp = nib.load(masks[0])
				affine = tmp.affine
				outmask = tmp.get_data()
				for mask in masks:
					outmask *= nib.load(mask).get_data()
				nib.save(nib.Nifti1Image(outmask,affine),"TBSS/mean_FA_mask.nii.gz")

				#mean FA
				subject_list = " ".join(FA_std)
				os.system('%s/AverageImages 3 TBSS/average_FA.nii.gz 0 %s' % (ANTSPATH,subject_list))
				os.system('%s/bin/fslmaths TBSS/average_FA.nii.gz -mul TBSS/mean_FA_mask.nii.gz TBSS/mean_FA.nii.gz' % FSLDIR)

				#skeletonise mean FA
				os.system('%s/bin/tbss_skeleton -i TBSS/mean_FA -o TBSS/mean_FA_skeleton' % FSLDIR)

				#theshold
				os.system('%s/bin/fslmaths TBSS/mean_FA_skeleton -thr %s -bin TBSS/mean_FA_skeleton_mask' % (FSLDIR, thresh))

				#build all_FA image
				mask_index = outmask!=0

				os.system('%s/bin/fslmaths TBSS/mean_FA_mask -mul -1 -add 1 -add TBSS/mean_FA_skeleton_mask TBSS/mean_FA_skeleton_mask_dst' % FSLDIR)
				os.system('%s/bin/distancemap -i TBSS/mean_FA_skeleton_mask_dst -o TBSS/mean_FA_skeleton_mask_dst' % FSLDIR)


				os.system("mkdir TBSS/FA_masked")
				os.system("mkdir TBSS/FA_skeleton")

				for img in FA_std:
					img_name = "TBSS/FA_masked/%s" % os.path.basename(img)
					img_name_skel = "TBSS/FA_skeleton/skel_%s" % os.path.basename(img)
					img_data = nib.load(img).get_data()
					img_data[mask_index==False] = 0
					nib.save(nib.Nifti1Image(img_data,affine),img_name)
					os.system('echo %s/bin/tbss_skeleton -i TBSS/mean_FA -p %s TBSS/mean_FA_skeleton_mask_dst %s/data/standard/LowerCingulum_1mm %s %s >> cmd_skel_FA_parallel' % (FSLDIR, thresh, os.environ['FSLDIR'], img_name, img_name_skel))
				os.system("cat cmd_skel_FA_parallel | parallel -j %d; rm cmd_skel_FA_parallel" % (num_threads))

			# OTHER METRIC SKELETONIZATION
			else:
				os.system("mkdir TBSS/%s_masked" % METRIC)
				os.system("mkdir TBSS/%s_skeleton" % METRIC)
				outmask = nib.load("TBSS/mean_FA_mask.nii.gz").get_data()
				mask_index = outmask!=0
				FA_std = get_wildcard('FA/*FA_to_stdT1.nii.gz')
				metric_std = get_wildcard('%s/*%s_to_stdT1.nii.gz' % (METRIC,METRIC))
				for a, img in enumerate(metric_std):
					fa_img = FA_std[a]
					img_name = "TBSS/%s_masked/%s" % (METRIC, os.path.basename(img))
					img_name_skel = "TBSS/%s_skeleton/skel_%s" % (METRIC, os.path.basename(img))
					img_data = nib.load(img).get_data()
					img_data[mask_index==False] = 0
					nib.save(nib.Nifti1Image(img_data,affine),img_name)
					os.system('echo %s/bin/tbss_skeleton -i TBSS/mean_FA -p %s TBSS/mean_FA_skeleton_mask_dst %s/data/standard/LowerCingulum_1mm %s %s -a %s >> cmd_skel_%s_parallel' % (FSLDIR, thresh, os.environ['FSLDIR'], fa_img, img_name_skel, img_name, METRIC))
				os.system("cat cmd_skel_%s_parallel | parallel -j %d; rm cmd_skel_%s_parallel" % (METRIC, num_threads, METRIC))

if __name__ == "__main__":
	parser = getArgumentParser()
	opts = parser.parse_args()
	run(opts)
