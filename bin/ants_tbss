#!/usr/bin/env python

import os
import numpy as np
import argparse
import nibabel as nib
import json

from ants_tbss.functions import get_wildcard, antsLinearRegCmd, antsNonLinearRegCmd, antsApplyTransformCmd, antsBetCmd

DESCRIPTION = "Just a TBSS (FSL) implementation with ANTs and T1w registration to template."

def getArgumentParser(parser = argparse.ArgumentParser(description = DESCRIPTION)):
	registration = parser.add_mutually_exclusive_group(required=True)
	registration.add_argument("-ar", "--antsregtotemplate", 
		nargs = 2,
		help = "Register B0 to native T1w brain image. -ar {B0 list} {T1w list}",
		metavar = 'str')
	registration.add_argument("-j", "--jsontransformlist", 
		nargs = 1,
		help = "-j {json list}",
		metavar = 'str')
	parser.add_argument("-r", "--runtbss", 
		nargs = '+',
		help="For skeletonization of dwi metrics in template (standard) space, input a text file of the directory locations of the images and the metric name. The first input must be for FA (or the FA skeletonization has to be detected). -r {metric_list} {metric_name} ...")

	# options
	parser.add_argument("-ab","--runantsbet",
		action = 'store_true',
		help="Run ANTs bet on the T1w images. Use this if your T1 inputs are not already brain extracted. Arguably, ANTs does a must better brain extraction than FSL's bet or freesurfer's watershed.")

	# settings
	parser.add_argument("-t","--threshold",
		nargs=1,
		help="Set threshold level. Default: %(default)s)",
		default=['0.2'],
		metavar=('float'))
	parser.add_argument("-nt", "--numthreads", 
		nargs=1,
		default=['12'],
		help="multithreading")
	parser.add_argument("-std", "--templateimage", 
		nargs=1,
		default=['%s/data/standard/MNI152_T1_1mm_brain.nii.gz' % os.environ['FSLDIR']],
		metavar=('img'),
		help="Template (standard) image. Default: %(default)s). -std PATH/TO/TEMPLATE.nii.gz")
	parser.add_argument("--searchrulemask", 
		nargs=1,
		default=['%s/data/standard/LowerCingulum_1mm.nii.gz' % os.environ['FSLDIR']],
		metavar=('img'),
		help="Search rule mask for skeletonization. Default: %(default)s). -std PATH/TO/SEARCH_RULE_MASK.nii.gz")

	return parser

def run(opts):

	thresh = float(opts.threshold[0])
	num_threads = int(opts.numthreads[0])
	std_brain = opts.templateimage[0]
	current_dir = os.getcwd()

	assert "ANTSPATH" in os.environ, "The environment variable ANTSPATH must be declared."
	ANTSPATH = os.environ['ANTSPATH']
	assert "FSLDIR" in os.environ, "The environment variable FSLDIR must be declared."
	FSLDIR = os.environ['FSLDIR']

	if opts.antsregtotemplate:
		# create empty warp list to populate
		warp_list = []
		mask_list = []

		# read list files
		B0_list = np.genfromtxt(opts.antsregtotemplate[0], dtype=str)
		T1_native_list = np.genfromtxt(opts.antsregtotemplate[1], dtype=str)

		print("Running registration of B0 images -> T1w images -> template T1 image")
		os.system("mkdir -p reg")

		assert len(B0_list) == len(T1_native_list), "The image lists are not of equal length."

		for i, b0 in enumerate(B0_list):
			temp_transformation = {}
			b0_name = os.path.basename(b0)[:-7]
			t1_name = os.path.basename(T1_native_list[i])[:-7]

			mask_name = "reg/%s_mask.nii.gz" % b0_name
			mask_name_t1 = "reg/%s_mask_to_natT1.nii.gz" % b0_name
			mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % b0_name
			t1_mask_name = "reg/%s_mask.nii.gz" % t1_name
			t1_mask_name_std = "reg/%s_mask_to_stdT1.nii.gz" % t1_name


			ref = T1_native_list[i]
			temp_transformation['nativeT1'] = T1_native_list[i]

			mov = b0
			log = "reg/lin%s_to_natT1.log" % b0_name
			out = "reg/%s_to_natT1.nii.gz" % b0_name
			os.system("fslmaths %s -bin %s" % (mov, mask_name))

			# linear reg of B0 to T1w native image
			os.system("%s > %s" % (antsLinearRegCmd(int(num_threads), ref, mov, out), log))
			temp_transformation['linB0_to_natT1'] = ['%s/%s_0GenericAffine.mat' % (current_dir, out)]

			# move the mask
			os.system(antsApplyTransformCmd(reference = ref, mov = mask_name, warps = ['%s_0GenericAffine.mat' % out], outname = mask_name_t1, outdir = None))
			img = nib.load(mask_name_t1)
			img_data = img.get_data()
			img_data = np.round(img_data)
			nib.save(nib.Nifti1Image(img_data,img.affine),mask_name_t1)

			# linear/non-linear reg T1 to std
			ref = std_brain
			mov = T1_native_list[i]
			log = "reg/lin%s_to_stdT1.log" % t1_name
			out = "reg/lin%s_to_stdT1.nii.gz" % t1_name
			os.system("%s > %s" % (antsLinearRegCmd(int(num_threads), ref, mov, out), log))

			# get mask of T1
			os.system("fslmaths %s -bin %s" % (mov, t1_mask_name))

			# non-linear
			mov = out
			log = "reg/%s_to_stdT1.log" % t1_name
			out = "reg/%s_to_stdT1.nii.gz" % t1_name
			os.system("%s > %s" % (antsNonLinearRegCmd(int(num_threads), ref, mov, out), log))

			# move FA mask
			warps = ['%s_0Warp.nii.gz' % (out), 'reg/lin%s_to_stdT1.nii.gz_0GenericAffine.mat' % (t1_name)]
			temp_transformation['T1to_stdT1'] = ['%s/%s_0Warp.nii.gz' % (current_dir, out), '%s/reg/lin%s_to_stdT1.nii.gz_0GenericAffine.mat' % (current_dir, t1_name)]



			os.system(antsApplyTransformCmd(reference = ref, mov = mask_name_t1, warps = warps, outname = mask_name_std, outdir = None))
			img = nib.load(mask_name_std)
			img_data = img.get_data()
			img_data = np.round(img_data)
			nib.save(nib.Nifti1Image(img_data,img.affine),mask_name_std)
			# move T1 mask
			os.system(antsApplyTransformCmd(reference = ref, mov = t1_mask_name, warps = warps, outname = t1_mask_name_std, outdir = None))
			img = nib.load(t1_mask_name_std)
			img_data = img.get_data()
			img_data = np.round(img_data)
			nib.save(nib.Nifti1Image(img_data,img.affine),t1_mask_name_std)

			mask_list.append(mask_name_std)
			mask_list.append(t1_mask_name_std)

			temp_transformation['mask_name_std'] = mask_name_std
			temp_transformation['t1_mask_name_std'] = t1_mask_name_std

			# Write out the processing settings
			with open('reg/%s_warps.json' % b0_name, 'w') as outfile:
				json.dump(temp_transformation, outfile, indent=3, sort_keys=True)
			warp_list.append('reg/%s_warps.json' % b0_name)

		warp_list = np.array(warp_list, dtype = str)

	if opts.jsontransformlist:
		warp_list = np.genfromtxt(opts.jsontransformlist[0], dtype=str)

	if opts.runtbss:

		# Check runtbss inputs
		assert len(opts.runtbss) % 2 == 0, "--runtbss must have an even number of inputs. e.g., -r FA_list FA MD_list MD."

		# Check warp list length.
		assert len(warp_list) == len(np.genfromtxt(opts.runtbss[0], dtype=str)), "The length the --runtbss inputs must match the number of warps."

		linB0_to_natT1 = []
		T1to_stdT1 = []
		std_masks = []
		T1_ref = []
		# read the json files containing the warps and mask files
		for json_warp_file in warp_list:
			with open(json_warp_file) as json_file:
				transform_files = json.load(json_file)
				linB0_to_natT1.append(transform_files['linB0_to_natT1'])
				T1to_stdT1.append(transform_files['T1to_stdT1'])
				std_masks.append(transform_files['mask_name_std'])
				std_masks.append(transform_files['t1_mask_name_std'])
				T1_ref.append(transform_files['nativeT1'])

		num_metrics = int(np.divide(len(opts.runtbss),2))
		for m in range(num_metrics):
			METRICS_list = np.genfromtxt(opts.runtbss[int(m*2)])
			METRIC = opts.runtbss[(int(m*2)+1)]
			if METRIC != 'FA':
				assert (os.path.exists('TBSS/mean_FA_skeleton_mask_dst.nii.gz')), "FA skeletonization must be run first."

			os.system("mkdir -p %s_native" % METRIC)
			os.system("mkdir -p %s" % METRIC)

			# transform the metric images to standard space
			for i, metric_img in enumerate(METRICS_list):
				metric_name = os.path.basename(metric_img)[:-7]
				# set output names
				metric_nat = '%s_native/%s_to_natT1.nii.gz' % (METRIC, metric_name)
				metric_std = '%s/%s_to_stdT1.nii.gz' % (METRIC, metric_name)

				# metric to native
				ref = T1_ref[i]
				mov = metric_img
				warps = linB0_to_natT1[i]
				os.system(antsApplyTransformCmd(reference = ref, mov = mov, warps = warps, outname = metric_nat))

				# metric to template
				ref = std_brain
				mov = metric_nat
				warps = T1to_stdT1[i]
				os.system(antsApplyTransformCmd(reference = ref, mov = mov, warps = warps, outname = metric_std))


			#### Skeletonization ####
			if METRIC == 'FA':
				tbssdir = 'TBSS'
				os.system("mkdir %s" % tbssdir)
				FA_std = get_wildcard('FA/*FA_to_stdT1.nii.gz')
				# build all_FA_mask
				masks = std_masks
				# check lengths
				assert len(FA_std)*2 == len(masks), "The image lists are not equal to the number of masks."

				#get first mask
				tmp = nib.load(masks[0])
				affine = tmp.affine
				outmask = tmp.get_data()
				for mask in masks:
					outmask *= nib.load(mask).get_data()
				nib.save(nib.Nifti1Image(outmask,affine),"TBSS/mean_FA_mask.nii.gz")

				#mean FA
				subject_list = " ".join(FA_std)
				os.system('%s/AverageImages 3 TBSS/average_FA.nii.gz 0 %s' % (ANTSPATH,subject_list))
				os.system('%s/bin/fslmaths TBSS/average_FA.nii.gz -mul TBSS/mean_FA_mask.nii.gz TBSS/mean_FA.nii.gz' % FSLDIR)

				#skeletonise mean FA
				os.system('%s/bin/tbss_skeleton -i TBSS/mean_FA -o TBSS/mean_FA_skeleton' % FSLDIR)

				#theshold
				os.system('%s/bin/fslmaths TBSS/mean_FA_skeleton -thr %s -bin TBSS/mean_FA_skeleton_mask' % (FSLDIR, thresh))

				#build all_FA image
				mask_index = outmask!=0

				os.system('%s/bin/fslmaths TBSS/mean_FA_mask -mul -1 -add 1 -add TBSS/mean_FA_skeleton_mask TBSS/mean_FA_skeleton_mask_dst' % FSLDIR)
				os.system('%s/bin/distancemap -i TBSS/mean_FA_skeleton_mask_dst -o TBSS/mean_FA_skeleton_mask_dst' % FSLDIR)


				os.system("mkdir TBSS/FA_masked")
				os.system("mkdir TBSS/FA_skeleton")

				for img in FA_std:
					img_name = "TBSS/FA_masked/%s" % os.path.basename(img)
					img_name_skel = "TBSS/FA_skeleton/skel_%s" % os.path.basename(img)
					img_data = nib.load(img).get_data()
					img_data[mask_index==False] = 0
					nib.save(nib.Nifti1Image(img_data,affine),img_name)
					os.system('echo %s/bin/tbss_skeleton -i TBSS/mean_FA -p %s TBSS/mean_FA_skeleton_mask_dst %s/data/standard/LowerCingulum_1mm %s %s >> cmd_skel_FA_parallel' % (FSLDIR, thresh, os.environ['FSLDIR'], img_name, img_name_skel))
				os.system("cat cmd_skel_FA_parallel | parallel -j %d" % (num_threads))

			# OTHER METRIC SKELETONIZATION
			else:
				outmask = nib.load("TBSS/mean_FA_mask.nii.gz").get_data()
				mask_index = outmask!=0
				FA_std = get_wildcard('FA/*FA_to_stdT1.nii.gz')
				metric_std = get_wildcard('%s/*%s_to_stdT1.nii.gz' % (METRIC,METRIC))
				for a, img in enumerate(metric_std):
					fa_img = FA_std[a]
					img_name = "TBSS/%s_masked/%s" % (METRIC, os.path.basename(img))
					img_name_skel = "TBSS/%s_skeleton/skel_%s" % (METRIC, os.path.basename(img))
					img_data = nib.load(img).get_data()
					img_data[mask_index==False] = 0
					nib.save(nib.Nifti1Image(img_data,affine),img_name)
					os.system('echo %s/bin/tbss_skeleton -i TBSS/mean_FA -p %s TBSS/mean_FA_skeleton_mask_dst %s/data/standard/LowerCingulum_1mm %s %s -a %s >> cmd_skel_%s_parallel' % (FSLDIR, thresh, os.environ['FSLDIR'], fa_img, img_name_skel, img_name, METRIC))
				os.system("cat cmd_skel_%s_parallel | parallel -j %d" % (num_threads, METRIC))

if __name__ == "__main__":
	parser = getArgumentParser()
	opts = parser.parse_args()
	run(opts)
